{"version":3,"sources":["../src/types.ts","../src/index.ts"],"sourcesContent":["export const BETTING_TYPES = ['Single', 'Double', 'Treble'];\n\nexport type Bet = {\n  outcomeId: string;\n  eventId: string;\n  odds: string;\n  singlesStakeAmount?: number;\n  banker?: boolean;\n  marketTypeId: string;\n  marketTypeCombiningIds: string[];\n  specialValues?: { modelId: string | null }[];\n};\n\nexport type BetType = {\n  requiredHitCount: number;\n  stakeAmountPerCombination: number;\n};\n\nexport type BetSlipRequest = {\n  bets: Bet[];\n  betTypes?: BetType[];\n};\n\nexport type BetSlipMaxPayoutResult = {\n  maxPayout: number;\n  totalStakeAmount: number;\n  maxTotalStakeAmount: number;\n};\n\nexport type CalculateCashoutAmountParams = {\n  stake: number;\n  initialOdds: number;\n  currOddWinProb: number;\n  uniqueMarketMargin: number;\n};\n","// Types\r\nimport {\r\n  BETTING_TYPES,\r\n  Bet,\r\n  BetSlipMaxPayoutResult,\r\n  BetSlipRequest,\r\n  CalculateCashoutAmountParams,\r\n} from './types';\r\n\r\n/**\r\n * Calculates total odds from the given bets.\r\n * @param bets - Bets\r\n * @returns total odds\r\n */\r\nexport const calculateTotalOddsForNormalBettingSlip = (bets: Bet[]): number => {\r\n  const listOfOdds = bets.map((bet) => Number(bet.odds));\r\n  return listOfOdds.reduce((accumulator, odds) => accumulator * odds, 1);\r\n};\r\n\r\n/**\r\n * Calculate max stake amount.\r\n * @param totalOdds - Total odds.\r\n * @param maxWinning - Max winning.\r\n * @returns max stake amount\r\n */\r\nexport const calculateMaxStakeAmountForNormalBettingSlip = (\r\n  totalOdds: number,\r\n  maxWinning: number,\r\n): number => {\r\n  let rawStakeAmount = maxWinning / totalOdds;\r\n  let roundedStakeAmount = +rawStakeAmount.toFixed(2);\r\n\r\n  let maxPayout = totalOdds * roundedStakeAmount;\r\n  while (maxPayout > maxWinning) {\r\n    rawStakeAmount -= 0.01;\r\n    roundedStakeAmount = +rawStakeAmount.toFixed(2);\r\n    maxPayout = totalOdds * roundedStakeAmount;\r\n  }\r\n\r\n  return roundedStakeAmount;\r\n};\r\n\r\n/**\r\n * Generate combination type and number of combinations for system and system ways betting slips.\r\n * @param bets - Bets\r\n * @param lastCombination - Flag for getting last combination size\r\n * @returns record with combination type and number of combinations\r\n */\r\nexport const getCombinations = (\r\n  bets: Bet[],\r\n  lastCombination: boolean = false,\r\n): Record<string, number> => {\r\n  const betsWithoutBankers = bets.filter((bet) => !bet.banker);\r\n  const combinations: Record<string, number> = {};\r\n  const numberOfBankers = bets.length - betsWithoutBankers.length;\r\n\r\n  if (lastCombination) {\r\n    let numberOfCombinations;\r\n    let lastSize = betsWithoutBankers.length;\r\n    while (\r\n      (!numberOfCombinations || numberOfCombinations === 0) &&\r\n      lastSize > 0\r\n    ) {\r\n      numberOfCombinations = generateCombinations(\r\n        betsWithoutBankers,\r\n        lastSize,\r\n      ).length;\r\n\r\n      if (numberOfCombinations > 0) {\r\n        combinations[getBettingType(numberOfBankers + lastSize)] =\r\n          numberOfCombinations;\r\n\r\n        break;\r\n      }\r\n      lastSize -= 1;\r\n    }\r\n\r\n    return combinations;\r\n  }\r\n\r\n  for (let i = 1; i <= betsWithoutBankers.length; i++) {\r\n    const numberOfCombinations = generateCombinations(\r\n      betsWithoutBankers,\r\n      i,\r\n    ).length;\r\n    if (numberOfCombinations > 0) {\r\n      combinations[getBettingType(numberOfBankers + i)] = numberOfCombinations;\r\n    }\r\n  }\r\n\r\n  return combinations;\r\n};\r\n\r\n/**\r\n * Calculate total max payout, total stake amount and max total stake amount.\r\n * If the calculated max payout is higher then max possible payout, then max payout is set to max possible payout.\r\n * @param betSlipRequest - Bet Slip Request\r\n * @param maxWinning - Max winning\r\n * @param maxStakeAmount - Max Stake Amount\r\n * @returns max payout and total stake amount\r\n */\r\nexport const calculateMaxPayout = (\r\n  betSlipRequest: BetSlipRequest,\r\n  maxWinning: number,\r\n  maxStakeAmount: number,\r\n): BetSlipMaxPayoutResult => {\r\n  let maxPayout = 0;\r\n  let totalStakeAmount = 0;\r\n  let maxTotalStakeAmount = 0;\r\n  const { bets, betTypes } = betSlipRequest;\r\n\r\n  for (const bet of bets) {\r\n    if (!bet.singlesStakeAmount) continue;\r\n    const payout = Number(bet.odds) * bet.singlesStakeAmount;\r\n\r\n    maxPayout += payout < maxWinning ? payout : maxWinning;\r\n    totalStakeAmount += bet.singlesStakeAmount;\r\n    maxTotalStakeAmount += maxStakeAmount;\r\n  }\r\n\r\n  if (betTypes?.length > 0) {\r\n    const bankerOutcomes = bets.filter((bet) => bet.banker);\r\n    const combinationOutcomes = bets.filter((bet) => !bet.banker);\r\n    for (const betType of betTypes) {\r\n      const { requiredHitCount, stakeAmountPerCombination } = betType;\r\n\r\n      const combinations = generateCombinations(\r\n        combinationOutcomes,\r\n        requiredHitCount,\r\n      );\r\n\r\n      const payout = calculateSystemMaxPayout(\r\n        combinations,\r\n        stakeAmountPerCombination,\r\n        bankerOutcomes,\r\n      );\r\n\r\n      maxPayout += payout < maxWinning ? payout : maxWinning;\r\n      totalStakeAmount += stakeAmountPerCombination * combinations.length;\r\n      maxTotalStakeAmount += maxStakeAmount;\r\n    }\r\n  }\r\n\r\n  return { maxPayout, totalStakeAmount, maxTotalStakeAmount };\r\n};\r\n\r\n/**\r\n * Get betting type by the given number of bets.\r\n * @param numberOfBets - Number of bets\r\n * @returns betting type value\r\n */\r\nexport const getBettingType = (numberOfBets: number) => {\r\n  return BETTING_TYPES[numberOfBets - 1] ?? `${numberOfBets} Fold`;\r\n};\r\n\r\n/**\r\n * Calculate system betting slip max payout.\r\n * If the calculated max payout is higher then max possible payout, then max payout is set to max possible payout.\r\n * @param combinations - System combinations of outcomes.\r\n * @param stakeAmountPerCombination - Stake amount per combination.\r\n * @param bankerOutcomes - Banker outcomes.\r\n * @returns max payout\r\n */\r\nconst calculateSystemMaxPayout = (\r\n  combinations: Bet[][],\r\n  stakeAmountPerCombination: number,\r\n  bankerOutcomes: Bet[],\r\n): number => {\r\n  let maxPayout = 0;\r\n\r\n  for (const combination of combinations) {\r\n    const listOfOdds: number[] = [\r\n      ...bankerOutcomes.map((outcome) => Number(outcome.odds)),\r\n      ...combination.map((comb) => Number(comb.odds)),\r\n    ];\r\n    const payoutPerCombination =\r\n      listOfOdds.reduce((accumulator, odds) => accumulator * odds, 1) *\r\n      stakeAmountPerCombination;\r\n    maxPayout += payoutPerCombination;\r\n  }\r\n\r\n  return maxPayout;\r\n};\r\n\r\n/**\r\n * Create map where we will store market type id as key and modelIds from SV as value\r\n * @param combo - Current combo\r\n * @returns map\r\n */\r\nconst createMarketTypeSVModelIdsMap = (combo: Bet[]): Map<string, string[]> => {\r\n  const marketTypeModelIdMap = new Map<string, string[]>();\r\n\r\n  for (const bet of combo) {\r\n    const { marketTypeId, specialValues } = bet;\r\n\r\n    // Initialize map entry if it doesn't exist\r\n    if (!marketTypeModelIdMap.has(marketTypeId)) {\r\n      marketTypeModelIdMap.set(marketTypeId, []);\r\n    }\r\n\r\n    if (specialValues?.length) {\r\n      // Extract modelIds from specialValues and append to the corresponding marketTypeId\r\n      const modelIds = specialValues\r\n        .map((specialValue) => specialValue?.modelId)\r\n        .filter(Boolean);\r\n      marketTypeModelIdMap.get(marketTypeId)?.push(...modelIds);\r\n    }\r\n  }\r\n  return marketTypeModelIdMap;\r\n};\r\n\r\n/**\r\n * Return boolean if one of the market type id keys has duplicated values of model ids.\r\n * It means that we have same market type for same participant on one event.\r\n * @param map - Map\r\n * @returns\r\n */\r\nconst hasDuplicateModelIds = (map: Map<string, string[]>): boolean => {\r\n  return [...map.values()].some((modelIds) => {\r\n    const uniqueModelIds = new Set(modelIds);\r\n    return uniqueModelIds.size !== modelIds.length;\r\n  });\r\n};\r\n\r\n/**\r\n * Generate combinations of outcomes by the given size (required hit count).\r\n * Outcomes from the same event cannot be in the combinations for system ways bets.\r\n * @param outcomes - Outcomes with details\r\n * @param size - Size of the combinations\r\n * @returns combinations\r\n */\r\nconst generateCombinations = (outcomes: Bet[], size: number): Bet[][] => {\r\n  const result: Bet[][] = [];\r\n\r\n  function generate(\r\n    currentCombo: Bet[],\r\n    start: number,\r\n    usedEventIds: Set<string>,\r\n  ): void {\r\n    if (currentCombo.length === size) {\r\n      result.push([...currentCombo]);\r\n      return;\r\n    }\r\n\r\n    for (let i = start; i < outcomes.length; i++) {\r\n      const currentOutcome = outcomes[i];\r\n      const { eventId, marketTypeCombiningIds } = currentOutcome;\r\n\r\n      if (!usedEventIds.has(eventId)) {\r\n        currentCombo.push(currentOutcome);\r\n\r\n        usedEventIds.add(eventId);\r\n\r\n        generate(currentCombo, i + 1, usedEventIds);\r\n\r\n        currentCombo.pop();\r\n        usedEventIds.delete(eventId);\r\n      } else {\r\n        // Case when the outcome is from an already used event\r\n        // Check if all of the market types in the current combination can combine with the new outcome\r\n        const currentComboFromSameEvent = currentCombo.filter(\r\n          (outcome) => outcome.eventId === eventId,\r\n        );\r\n        const canCombineMarketTypes = currentComboFromSameEvent.every(\r\n          (outcome) => {\r\n            const existingMarketTypeId = outcome.marketTypeId;\r\n            return marketTypeCombiningIds.includes(existingMarketTypeId);\r\n          },\r\n        );\r\n\r\n        // Add current outcome to current combo from same event to create map of [marketTypeId:string] : modelIds string[]\r\n        const marketTypeSpecialValuesMap = createMarketTypeSVModelIdsMap([\r\n          ...currentComboFromSameEvent,\r\n          currentOutcome,\r\n        ]);\r\n        const canCombineMarketTypesWithSVModelIds = !hasDuplicateModelIds(\r\n          marketTypeSpecialValuesMap,\r\n        );\r\n\r\n        if (canCombineMarketTypes && canCombineMarketTypesWithSVModelIds) {\r\n          currentCombo.push(currentOutcome);\r\n\r\n          generate(currentCombo, i + 1, usedEventIds);\r\n\r\n          currentCombo.pop();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  generate([], 0, new Set<string>());\r\n  return result;\r\n};\r\n\r\n/**\r\n *\r\n * @param stake\r\n * @param initialOdds\r\n * @param currOddWinProb\r\n * @param uniqueMarketMargin - Integer from 0 to 100 representing factor values from 0.00 to 1\r\n */\r\nexport const calculateCashoutAmount = ({\r\n  stake,\r\n  initialOdds,\r\n  currOddWinProb,\r\n  uniqueMarketMargin,\r\n}: CalculateCashoutAmountParams): number =>\r\n  stake * initialOdds * currOddWinProb * (uniqueMarketMargin / 100);\r\n"],"mappings":"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","names":[]}